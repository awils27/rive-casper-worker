<!doctype html>
<html lang="en" data-theme="dark">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rive → CasparCG Generator</title>
  <!-- PicoCSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
  <style>
    /* minor tweaks */
    header {
      padding: 1.25rem 0 0.25rem;
    }

    .center {
      text-align: center;
    }

    .sticky-footer {
      position: sticky;
      bottom: 0;
      padding: 0.75rem 0;
      background: var(--pico-background-color);
    }

    .muted {
      color: var(--pico-muted-color);
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    }

    #props code,
    #inputs code {
      margin-right: .5rem;
    }

    #props small,
    #inputs small {
      opacity: .7;
    }

    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
    }

    @media (max-width: 900px) {
      .grid-2 {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>

<body>
  <header class="container center">
    <h2>Rive → CasparCG</h2>
    <p class="muted">Inspect .riv locally, map triggers, download a ready-made HTML template.</p>
  </header>

  <main class="container">
    <!-- Top: file chooser centered -->
    <article>
      <form id="fileForm" class="center">
        <label for="rivfile"><strong>Select a .riv file</strong></label>
        <input id="rivfile" type="file" accept=".riv" />
        <small id="fileStatus" class="muted">No file selected.</small>
      </form>
    </article>

    <!-- Detected structure & selectors -->
    <article id="detectedCard" style="display:none">
      <h4>Detected Structure</h4>
      <div class="grid-2">
        <div>
          <label for="artboardSel">Artboard</label>
          <select id="artboardSel"></select>
        </div>
        <div>
          <label for="smSel">State Machine</label>
          <select id="smSel"></select>
        </div>
      </div>

      <details open style="margin-top:1rem">
        <summary><strong>ViewModel Properties (data-binding)</strong></summary>
<div class="overflow-auto">
        <table id="propsTable" role="grid">
          <thead>
            <tr>
              <th scope="col">Name</th>
              <th scope="col">Type</th>
              <th scope="col">Sample JSON key</th>
              <th scope="col">Notes</th>
            </tr>
          </thead>
          <tbody id="propsBody"></tbody>
        </table>
        </div>

        <p id="propsEmpty" class="muted" style="display:none">No ViewModel properties found.</p>
      </details>


    </article>

    <!-- Caspar mapping + download -->
    <article id="mappingCard" style="display:none">
      <h4>CasparCG Animation Mapping</h4>
      <p class="muted">Choose which <em>trigger inputs</em> the template should call for Play/In, Out, and Next.
        (Optional; you can also drive triggers via <code class="mono">CG ... UPDATE</code>.)</p>
      <div class="grid-2">
        <div>
          <label for="inTriggerSel">Play / In trigger</label>
          <select id="inTriggerSel"></select>
        </div>
        <div>
          <label for="outTriggerSel">Out trigger</label>
          <select id="outTriggerSel"></select>
        </div>
      </div>
      <div style="margin-top:1rem">
        <label for="nextTriggerSel">Next trigger</label>
        <select id="nextTriggerSel"></select>
      </div>

      <fieldset role="group" style="margin-top:1.25rem">
        <input id="includeVmProps" type="checkbox" checked />
        <label for="includeVmProps">Include ViewModel property mapping in template</label>
      </fieldset>

      <div class="sticky-footer center">
        <button id="downloadBtn" class="contrast" disabled>Download Caspar Template</button>
        <p id="status" class="muted" style="margin:.5rem 0 0"></p>
      </div>
    </article>
  </main>

  <!-- Hidden canvas just to satisfy the Rive runtime (we don't render) -->
  <canvas id="hiddenCanvas" width="64" height="64" style="display:none"></canvas>

  <!-- Rive Web (Canvas) -->
  <script src="https://unpkg.com/@rive-app/canvas"></script>
  <script type="module">
    const $ = (s, el = document) => el.querySelector(s);
    const fileEl = $('#rivfile');
    const fileStatus = $('#fileStatus');
    const detectedCard = $('#detectedCard');
    const mappingCard = $('#mappingCard');
    const artSel = $('#artboardSel');
    const smSel = $('#smSel');
    const propsBox = $('#props');
    const inputsBox = $('#inputs');
    const inSel = $('#inTriggerSel');
    const outSel = $('#outTriggerSel');
    const nextSel = $('#nextTriggerSel');
    const includeVmPropsEl = $('#includeVmProps');
    const downloadBtn = $('#downloadBtn');
    const statusEl = $('#status');
    const canvas = $('#hiddenCanvas');
    const propsTable = $('#propsTable');
    const propsBody = $('#propsBody');
    const propsEmpty = $('#propsEmpty');

    let file, buffer, contents;
    let currentArt = '';
    let currentSM = '';
    let schema = null; // { artboard, stateMachine, inputs[], viewModelProps[] }

    fileEl.addEventListener('change', async () => {
      file = fileEl.files?.[0];
      if (!file) {
        fileStatus.textContent = 'No file selected.';
        return;
      }
      fileStatus.textContent = 'Reading file…';
      buffer = await file.arrayBuffer();
      await inspectContents();
      detectedCard.style.display = 'block';
      mappingCard.style.display = 'block';
      fileStatus.textContent = `Loaded ${file.name}`;
      downloadBtn.disabled = false;
    });

    async function inspectContents() {
      // First instance: read top-level contents (artboards, SMs)
      await new Promise((resolve, reject) => {
        const r = new rive.Rive({
          buffer, canvas, autoplay: false,
          onLoad() {
            try {
              contents = r.contents; // hierarchy summary (artboards, SMs, inputs)
              const artNames = (contents?.artboards || []).map(a => a.name);
              populateSelect(artSel, artNames, currentArt || artNames[0] || '');
              currentArt = artSel.value;

              const smsForArt = getSMsForArt(currentArt);
              populateSelect(smSel, smsForArt, currentSM || smsForArt[0] || '');
              currentSM = smSel.value;
            } finally {
              try { r.cleanup(); } catch { }
              resolve();
            }
          },
          onLoadError: reject
        });
      });

      // Second instance: bind to selected artboard/SM to get VM props & inputs
      await buildSchema(currentArt, currentSM);
      renderSchema();
    }

    artSel.addEventListener('change', async () => {
      currentArt = artSel.value;
      const sms = getSMsForArt(currentArt);
      populateSelect(smSel, sms, sms[0] || '');
      currentSM = smSel.value;
      await buildSchema(currentArt, currentSM);
      renderSchema();
    });

    smSel.addEventListener('change', async () => {
      currentSM = smSel.value;
      await buildSchema(currentArt, currentSM);
      renderSchema();
    });

    function getSMsForArt(artName) {
      const art = (contents?.artboards || []).find(a => a.name === artName);
      return (art?.stateMachines || []).map(sm => sm.name);
    }

    function populateSelect(sel, items, selected = '') {
      sel.innerHTML = '';
      if (!items || items.length === 0) {
        const opt = document.createElement('option');
        opt.value = ''; opt.textContent = '(none)';
        sel.appendChild(opt);
        sel.disabled = true;
        return;
      }
      sel.disabled = false;
      for (const name of items) {
        const opt = document.createElement('option');
        opt.value = name; opt.textContent = name;
        if (name === selected) opt.selected = true;
        sel.appendChild(opt);
      }
    }

async function buildSchema(artboard, stateMachine){
  schema = await new Promise((resolve, reject) => {
    const r = new rive.Rive({
      buffer, canvas,
      autoplay: false,
      artboard,
      stateMachines: stateMachine || undefined,
      autoBind: true,
      onLoad() {
        let viewModelProps = [];
        try {
          const vm = r.defaultViewModel?.();
          viewModelProps = vm?.properties
            ? vm.properties.map(p => ({ name: p.name, type: p.type }))  // includes 'trigger'
            : [];
        } catch {}
        resolve({ artboard, stateMachine, viewModelProps, inputs: [] });
        try { r.cleanup(); } catch {}
      },
      onLoadError: reject
    });
  });
}


function renderSchema(){
  // ViewModel table
  propsBody.innerHTML = '';
  if (!schema.viewModelProps.length) {
    propsTable.style.display = 'none';
    propsEmpty.style.display = 'block';
  } else {
    propsTable.style.display = '';
    propsEmpty.style.display = 'none';

    const rows = [...schema.viewModelProps].sort((a,b)=>a.name.localeCompare(b.name));
    for (const p of rows) {
      const note =
        p.type === 'color'   ? 'Accepts <code>#RRGGBB</code> or <code>0xAARRGGBB</code>' :
        p.type === 'trigger' ? 'Fire by mapping to Play/Out/Next or via UPDATE { "<name>": true }' :
        '';
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td><code>${escapeHtml(p.name)}</code></td>
        <td><small class="muted">${p.type}</small></td>
        <td><code>${escapeHtml(p.name)}</code></td>
        <td>${note}</td>
      `;
      propsBody.appendChild(tr);
    }
  }

  // Trigger mapping selects (from ViewModel properties only)
  const triggerNames = schema.viewModelProps.filter(p => p.type === 'trigger').map(p => p.name);
  populateSelect(inSel,   ['(none)', ...triggerNames], '(none)');
  populateSelect(outSel,  ['(none)', ...triggerNames], '(none)');
  populateSelect(nextSel, ['(none)', ...triggerNames], '(none)');
}


    downloadBtn.addEventListener('click', async () => {
      if (!schema) return;
      statusEl.textContent = 'Generating…';

      const options = {
        casparTriggers: {
          in: pickOrNull(inSel.value),
          out: pickOrNull(outSel.value),
          next: pickOrNull(nextSel.value)
        },
        includeViewModelProps: !!includeVmPropsEl.checked
      };

      // You can switch templates later; keeping "caspar-basic" here
      const payload = {
        template: 'caspar-basic',
        schema,
        filename: `caspar-${(file?.name || 'template').replace(/\.riv$/i, '')}.html`,
        options
      };

      const res = await fetch('/generate', {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(payload)
      });

      if (!res.ok) {
        statusEl.textContent = `Error: ${res.status} ${res.statusText}`;
        return;
      }

      const blob = await res.blob();
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = (res.headers.get('content-disposition')?.match(/filename="([^"]+)"/)?.[1]) || 'caspar-template.html';
      a.click();
      URL.revokeObjectURL(a.href);
      statusEl.textContent = 'Downloaded template.';
    });

    // helpers
    const pickOrNull = (v) => (v && v !== '(none)') ? v : null;
    const escapeHtml = (s) => String(s).replace(/[&<>"']/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c]));

  </script>
</body>

</html>